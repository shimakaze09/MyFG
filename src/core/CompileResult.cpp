//
// Created by Admin on 7/03/2025.
//

#include <MyFG/CompileResult.h>

#include <stack>

using namespace My;
using namespace My::FG;
using namespace std;

tuple<bool, vector<size_t>> CompileResult::PassGraph::TopoSort() const {
  unordered_map<size_t, size_t> in_degree_map;

  for (const auto& [parent, children] : adjList)
    in_degree_map.emplace(parent, 0);

  for (const auto& [parent, children] : adjList) {
    for (const auto& child : children)
      in_degree_map[child] += 1;
  }

  stack<size_t> zero_in_degree_vertices;
  vector<size_t> sorted_vertices;

  for (const auto& [v, d] : in_degree_map) {
    if (d == 0)
      zero_in_degree_vertices.push(v);
  }

  while (!zero_in_degree_vertices.empty()) {
    auto v = zero_in_degree_vertices.top();
    zero_in_degree_vertices.pop();
    sorted_vertices.push_back(v);
    in_degree_map.erase(v);
    for (auto child : adjList.find(v)->second) {
      auto target = in_degree_map.find(child);
      if (target == in_degree_map.end())
        continue;
      target->second--;
      if (target->second == 0)
        zero_in_degree_vertices.push(child);
    }
  }

  if (!in_degree_map.empty())
    return { false, vector<size_t>{} };

  return { true, sorted_vertices };
}

void CompileResult::Clear() {
  resource2info.clear();
  sortedPasses.clear();
  passgraph.Clear();
}
